#################################
## This code is generated by AI
#################################
import random
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Dict, Optional
from dataclasses import dataclass
from app.config import settings

from app.scripts.simulation_helpers import (
    DatabaseCleaner,
    StatisticsReporter,
    APIClient,
    GameSimulator
)

BASE_URL = "http://localhost:8000/api/v1"
DATABASE_URL = settings.DATABASE_URL

@dataclass
class GameResult:
    game_id: int
    winner_id: Optional[int]
    total_moves: int
    duration: float
    players: List[int]

class ConcurrentGameSimulator:
    def __init__(self, base_url: str = BASE_URL):
        self.base_url = base_url
        self.results_lock = threading.Lock()
        self.game_results: List[GameResult] = []
        self.created_players: List[int] = []
        self.created_sessions: List[int] = []
        
        # Initialize helper classes
        self.api_client = APIClient(base_url)
        self.game_simulator = GameSimulator(self.api_client)
        self.database_cleaner = DatabaseCleaner(DATABASE_URL)
        self.stats_reporter = StatisticsReporter()
    
    def create_player(self, username: str, email: str) -> Dict:
        """Create a player and track it for cleanup."""
        player_data = self.api_client.create_player(username, email)
        if player_data:
            self.created_players.append(player_data["id"])
        return player_data
    
    def simulate_single_game_tracked(self, game_id: int, player1_id: int, player2_id: int) -> GameResult:
        """Simulate a game and track session for cleanup."""
        # Override the API client's create_and_join_session to track sessions
        original_method = self.api_client.create_and_join_session
        
        def tracked_create_and_join(p1_id, p2_id):
            session_id = original_method(p1_id, p2_id)
            if session_id:
                self.created_sessions.append(session_id)
            return session_id
        
        # Temporarily replace the method
        self.api_client.create_and_join_session = tracked_create_and_join
        
        try:
            result = self.game_simulator.simulate_single_game(game_id, player1_id, player2_id)
        finally:
            # Restore original method
            self.api_client.create_and_join_session = original_method
        
        return result
    
    def run_concurrent_games(self, players: List[Dict], num_games: int, max_workers: int = 5):
        """Run multiple games concurrently using ThreadPoolExecutor."""
        print(f"Starting {num_games} concurrent games with {max_workers} workers...")
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # Submit all games to the thread pool
            future_to_game = {}
            
            for game_id in range(num_games):
                # Pick two random players
                player1, player2 = random.sample(players, 2)
                
                future = executor.submit(
                    self.simulate_single_game_tracked,
                    game_id,
                    player1["id"],
                    player2["id"]
                )
                future_to_game[future] = {
                    'game_id': game_id,
                    'player1': player1,
                    'player2': player2
                }
            
            # Process completed games as they finish
            completed_games = 0
            
            for future in as_completed(future_to_game):
                game_info = future_to_game[future]
                
                try:
                    result = future.result()
                    
                    with self.results_lock:
                        self.game_results.append(result)
                    
                    completed_games += 1
                    
                    # Print progress
                    if result.winner_id:
                        winner_name = next(
                            (p["username"] for p in players if p["id"] == result.winner_id),
                            f"Player {result.winner_id}"
                        )
                        print(f"Game {result.game_id + 1}/{num_games}: {winner_name} wins! "
                              f"({result.total_moves} moves, {result.duration:.2f}s)")
                    else:
                        print(f"Game {result.game_id + 1}/{num_games}: Draw "
                              f"({result.total_moves} moves, {result.duration:.2f}s)")
                    
                    # Progress indicator
                    if completed_games % 5 == 0:
                        print(f"Completed {completed_games}/{num_games} games...")
                        
                except Exception as e:
                    print(f"Game {game_info['game_id'] + 1} failed: {e}")
        
        print(f"All {num_games} games completed!")
    
    def cleanup_database(self):
        """Clean up all data created during simulation."""
        print("\nCleaning up simulation data...")
        
        cleanup_stats = self.database_cleaner.cleanup_via_database(
            self.created_players, self.created_sessions
        )
        
        # Print cleanup summary
        print(f"Cleanup completed:")
        print(f"  - Players deleted: {cleanup_stats['players_deleted']}")
        print(f"  - Sessions deleted: {cleanup_stats['sessions_deleted']}")
        print(f"  - Moves deleted: {cleanup_stats['moves_deleted']}")
        if cleanup_stats["errors"] > 0:
            print(f"  - Errors: {cleanup_stats['errors']}")
        
        # Clear tracking lists
        self.created_players.clear()
        self.created_sessions.clear()
        self.game_results.clear()
    
    def reset_database_for_clean_test(self):
        """Reset database to clean state before simulation."""
        self.database_cleaner.reset_database()
    
    def print_statistics(self, players: List[Dict]):
        """Print comprehensive game statistics."""
        self.stats_reporter.print_simulation_statistics(
            self.game_results, players, self.created_players, self.created_sessions
        )

def main():
    """Main simulation function."""
    simulator = ConcurrentGameSimulator()
    
    # Configuration
    NUM_PLAYERS = 8
    NUM_GAMES = 30
    MAX_WORKERS = 6
    
    print(f"CONCURRENT GRID GAME SIMULATION")
    print(f"Players: {NUM_PLAYERS}, Games: {NUM_GAMES}")
    print(f"Max Workers: {MAX_WORKERS}")
    print("=" * 50)
    
    # Ask about database reset
    reset_choice = input("\nReset database before simulation? (y/N): ").strip().lower()
    if reset_choice == 'y':
        simulator.reset_database_for_clean_test()
    
    # Create players
    print("Creating players...")
    players = []
    for i in range(NUM_PLAYERS):
        player = simulator.create_player(f"player_{i}", f"player_{i}@test.com")
        if player:
            players.append(player)
            print(f"Created {player['username']} (ID: {player['id']})")
    
    if len(players) < 2:
        print("Need at least 2 players to run simulation!")
        return
    
    print(f"\nRunning {NUM_GAMES} concurrent games...")
    start_time = time.time()
    
    try:
        # Run concurrent games
        simulator.run_concurrent_games(players, NUM_GAMES, MAX_WORKERS)
        
        total_time = time.time() - start_time
        print(f"\nSimulation completed in {total_time:.2f} seconds!")
        
        # Print statistics
        simulator.print_statistics(players)
        
    except KeyboardInterrupt:
        print("\nSimulation interrupted by user!")
    except Exception as e:
        print(f"\nSimulation failed: {e}")
    finally:
        # Always offer cleanup
        cleanup_choice = input("\nClean up simulation data? (Y/n): ").strip().lower()
        if cleanup_choice != 'n':
            simulator.cleanup_database()
        else:
            print("Simulation data left in database for inspection")
            print(f"   Players: {simulator.created_players}")
            print(f"   Sessions: {simulator.created_sessions}")

if __name__ == "__main__":
    main()