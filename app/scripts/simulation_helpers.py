#################################
## This code is generated by AI
#################################

import requests
import time
from typing import Dict, List, Optional
from collections import Counter, defaultdict
from app.database import SessionLocal
from app.player.models import Player
from app.game_session.models import GameSession
from app.move.models import Move

class DatabaseCleaner:
    """Handles database cleanup operations."""
    
    def __init__(self, base_url: str):
        self.base_url = base_url
    
    def cleanup_via_database(self, player_ids: List[int], session_ids: List[int]) -> Dict[str, int]:
        """Clean up data using direct database access."""
        cleanup_stats = {
            "players_deleted": 0,
            "sessions_deleted": 0,
            "moves_deleted": 0,
            "errors": 0
        }
        
        try:      
            db = SessionLocal()
            try:
                # Delete moves for sessions created during simulation
                if session_ids:
                    moves_deleted = db.query(Move).filter(
                        Move.session_id.in_(session_ids)
                    ).delete(synchronize_session=False)
                    cleanup_stats["moves_deleted"] = moves_deleted
                
                # Delete sessions created during simulation
                if session_ids:
                    sessions_deleted = db.query(GameSession).filter(
                        GameSession.id.in_(session_ids)
                    ).delete(synchronize_session=False)
                    cleanup_stats["sessions_deleted"] = sessions_deleted
                
                # Delete players created during simulation
                if player_ids:
                    players_deleted = db.query(Player).filter(
                        Player.id.in_(player_ids)
                    ).delete(synchronize_session=False)
                    cleanup_stats["players_deleted"] = players_deleted
                
                db.commit()
                
            except Exception as e:
                db.rollback()
                print(f"Database cleanup error: {e}")
                cleanup_stats["errors"] += 1
            finally:
                db.close()
                
        except ImportError:
            print("Direct database cleanup failed")
        return cleanup_stats
    

    
    def reset_database(self):
        """Reset database to clean state before simulation."""
        print("Resetting database to clean state...")
        
        try:
            from app.database import SessionLocal
            from app.player.models import Player
            from app.game_session.models import GameSession
            from app.move.models import Move
            
            db = SessionLocal()
            try:
                # Delete all data (use with caution!)
                db.query(Move).delete()
                db.query(GameSession).delete()
                db.query(Player).delete()
                db.commit()
                print("Database reset completed")
                
            except Exception as e:
                db.rollback()
                print(f"Database reset error: {e}")
            finally:
                db.close()
                
        except ImportError:
            print("Database reset not available - continuing with existing data...")

class StatisticsReporter:
    """Handles statistics reporting and analysis."""
    
    @staticmethod
    def print_simulation_statistics(game_results: List, players: List[Dict], 
                                   created_players: List[int], created_sessions: List[int]):
        """Print comprehensive game statistics."""
        if not game_results:
            print("No game results to analyze!")
            return
        
        print("\nSIMULATION STATISTICS")
        print("=" * 50)
        
        # Basic stats
        total_games = len(game_results)
        completed_games = len([r for r in game_results if r.winner_id])
        draws = total_games - completed_games
        
        print(f"Total games played: {total_games}")
        print(f"Games with winners: {completed_games}")
        print(f"Draws: {draws}")
        
        # Performance stats
        total_duration = sum(r.duration for r in game_results)
        avg_duration = total_duration / total_games
        avg_moves = sum(r.total_moves for r in game_results) / total_games
        
        print(f"Total simulation time: {total_duration:.2f} seconds")
        print(f"Average game duration: {avg_duration:.2f} seconds")
        print(f"Average moves per game: {avg_moves:.1f}")
        print(f"Games per second: {total_games / total_duration:.2f}")
        
        # Database impact
        print(f"\nDATABASE IMPACT:")
        print(f"Players created: {len(created_players)}")
        print(f"Sessions created: {len(created_sessions)}")
        print(f"Estimated moves created: {sum(r.total_moves for r in game_results)}")
        
        # Win statistics
        StatisticsReporter._print_win_statistics(game_results, players, total_games)
        
        # Efficiency statistics
        StatisticsReporter._print_efficiency_statistics(game_results, players)
        
        # Concurrent performance
        print(f"\nCONCURRENCY PERFORMANCE:")
        print(f"Peak concurrent games: {total_games}")
        print(f"Throughput: {total_games / total_duration:.2f} games/second")
    
    @staticmethod
    def _print_win_statistics(game_results: List, players: List[Dict], total_games: int):
        """Print win-based statistics."""
        win_counts = Counter(r.winner_id for r in game_results if r.winner_id)
        
        if win_counts:
            print(f"\nTOP PLAYERS BY WINS:")
            for player_id, wins in win_counts.most_common(3):
                player_name = next(p["username"] for p in players if p["id"] == player_id)
                win_rate = wins / total_games * 100
                print(f"  {player_name}: {wins} wins ({win_rate:.1f}%)")
    
    @staticmethod
    def _print_efficiency_statistics(game_results: List, players: List[Dict]):
        """Print efficiency-based statistics."""
        player_efficiency = defaultdict(list)
        for result in game_results:
            if result.winner_id:
                player_efficiency[result.winner_id].append(result.total_moves)
        
        if player_efficiency:
            print(f"\nTOP PLAYERS BY EFFICIENCY:")
            efficiency_ranking = []
            for player_id, moves_list in player_efficiency.items():
                avg_moves = sum(moves_list) / len(moves_list)
                player_name = next(p["username"] for p in players if p["id"] == player_id)
                efficiency_ranking.append((player_name, avg_moves, len(moves_list)))
            
            efficiency_ranking.sort(key=lambda x: x[1])  # Sort by avg moves
            
            for i, (name, avg_moves, wins) in enumerate(efficiency_ranking[:3]):
                print(f"  {i+1}. {name}: {avg_moves:.1f} moves/win ({wins} wins)")

class APIClient:
    """Handles API communication."""
    
    def __init__(self, base_url: str):
        self.base_url = base_url
    
    def create_player(self, username: str, email: str) -> Optional[Dict]:
        """Create a player via API."""
        try:
            response = requests.post(f"{self.base_url}/player/", json={
                "username": username,
                "email": email
            }, timeout=10)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error creating player {username}: {e}")
            return None
    
    def create_and_join_session(self, player1_id: int, player2_id: int) -> Optional[int]:
        """Create a session and have both players join."""
        try:
            # Player 1 creates session
            create_response = requests.post(f"{self.base_url}/gameSession/create", json={
                "player_id": player1_id
            }, timeout=10)
            create_response.raise_for_status()
            session_data = create_response.json()
            
            # Player 2 joins
            join_response = requests.post(f"{self.base_url}/gameSession/join/{session_data['session_code']}", json={
                "player_id": player2_id
            }, timeout=10)
            join_response.raise_for_status()
            
            return join_response.json()["session_id"]
        except Exception as e:
            print(f"Error creating session for players {player1_id}, {player2_id}: {e}")
            return None
    
    def get_session_state(self, session_id: int) -> Optional[Dict]:
        """Get current session state."""
        try:
            response = requests.get(f"{self.base_url}/gameSession/{session_id}", timeout=5)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error getting session {session_id} state: {e}")
            return None
    
    def make_move(self, session_id: int, player_id: int, row: int, col: int) -> Optional[Dict]:
        """Make a move in the game."""
        try:
            response = requests.post(f"{self.base_url}/move/", json={
                "session_id": session_id,
                "player_id": player_id,
                "row": row,
                "col": col
            }, timeout=5)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error making move for player {player_id} in session {session_id}: {e}")
            return None

class GameSimulator:
    """Handles individual game simulation logic."""
    
    def __init__(self, api_client: APIClient):
        self.api_client = api_client
    
    def simulate_single_game(self, game_id: int, player1_id: int, player2_id: int):
        """Simulate a single game between two players."""
        from dataclasses import dataclass
        
        @dataclass
        class GameResult:
            game_id: int
            winner_id: Optional[int]
            total_moves: int
            duration: float
            players: List[int]
        
        start_time = time.time()
        
        # Create session
        session_id = self.api_client.create_and_join_session(player1_id, player2_id)
        if not session_id:
            return GameResult(game_id, None, 0, time.time() - start_time, [player1_id, player2_id])
        
        current_player = player1_id
        other_player = player2_id
        moves_made = 0
        max_moves = 9
        
        for move_num in range(max_moves):
            # Get current game state
            session_state = self.api_client.get_session_state(session_id)
            if not session_state:
                break
            
            game_state = session_state["game_state"]
            
            # Find available positions
            available_positions = []
            for row in range(3):
                for col in range(3):
                    if game_state[row][col] == 0:
                        available_positions.append((row, col))
            
            if not available_positions:
                break
            
            # Make random move
            import random
            row, col = random.choice(available_positions)
            move_result = self.api_client.make_move(session_id, current_player, row, col)
            
            if not move_result:
                break
            
            moves_made += 1
            
            # Check if game ended
            if move_result["game_status"] == "COMPLETED":
                duration = time.time() - start_time
                return GameResult(
                    game_id=game_id,
                    winner_id=move_result["winner_id"],
                    total_moves=moves_made,
                    duration=duration,
                    players=[player1_id, player2_id]
                )
            
            # Switch players
            current_player, other_player = other_player, current_player
            
            # Small delay to avoid overwhelming the server
            time.sleep(0.01)
        
        # Game ended without a winner
        duration = time.time() - start_time
        return GameResult(game_id, None, moves_made, duration, [player1_id, player2_id])